stages:
  - build
  - deploy

variables:
  DOCKER_FILE: "Dockerfile"
  DOCKER_REGISTRY: "docker.io"
  DOCKER_CLI_EXPERIMENTAL: "enabled"
  DOCKER_HOST: tcp://docker:2375
  DOCKER_TLS_CERTDIR: ""

build-default:
  stage: build
  image: docker:latest
  services:
    - name: docker:dind
      alias: docker
  before_script:
    - echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" $DOCKER_REGISTRY --password-stdin
  script:
    - >
      docker build
      -t index.docker.io/bbertka/stock-flask-app:latest
      -f $DOCKER_FILE .
    - docker push index.docker.io/bbertka/stock-flask-app:latest
  only:
    - main

build-arm64:
  stage: build
  image: docker:latest
  services:
    - name: docker:dind
      alias: docker
  before_script:
    - echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" $DOCKER_REGISTRY --password-stdin
    - docker run --rm --privileged multiarch/qemu-user-static --reset -p yes # Register QEMU as a handler for non-native architectures
    - docker buildx create --use
  script:
    - >
      docker buildx build
      --platform linux/arm64
      -t index.docker.io/bbertka/stock-flask-app-arm64:latest
      -f $DOCKER_FILE
      --push .
  only:
    - main

deploy-k3s:
  stage: deploy
  image: alpine/k8s:1.29.2

  script:
    - kubectl config set-cluster default-cluster --server=$KUBE_URL --insecure-skip-tls-verify=true
    - kubectl config set-credentials default-user --token=$KUBE_TOKEN
    - kubectl config set-context default --cluster=default-cluster --user=default-user --namespace=$KUBE_NAMESPACE
    - kubectl config use-context default
    - kubectl apply -f deployment.yml
  only:
    - main

restart_deployment:
  stage: deploy
  before_script:
    - apk add --no-cache yq # Ensures yq is available for parsing YAML
  script:
    - DEPLOYMENT_NAME=$(yq e '.metadata.name' deployment.yml) # Ensure this file path is correct
    - kubectl rollout restart deployment/$DEPLOYMENT_NAME -n $KUBE_NAMESPACE
  only:
    - main
